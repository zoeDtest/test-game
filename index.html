


<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <!-- 强制竖屏，禁止缩放 -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Moon Runner: Dark Side</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@500;700&display=swap');

        /* --- 1. 基础布局 --- */
        body {
            margin: 0; padding: 0;
            background: #000;
            height: 100vh; width: 100vw;
            overflow: hidden;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Rajdhani', sans-serif;
            user-select: none; -webkit-user-select: none;
            touch-action: none;
        }

        /* 背景层 */
        #stars-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(to bottom, #050510 0%, #101025 100%);
            z-index: -1;
        }

        /* 游戏容器 - 9:16 竖屏比例 */
        #game-container {
            position: relative;
            width: 100%; height: 100%;
            max-width: 450px; /* 限制在大屏上的最大宽度 */
            aspect-ratio: 9/16;
            background: #000;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.15);
            overflow: hidden;
        }
        /* 隐藏关激活时的红色氛围 */
        #game-container.dark-mode {
            box-shadow: 0 0 30px rgba(255, 50, 50, 0.3);
            border: 1px solid #522;
        }

        canvas { display: block; width: 100%; height: 100%; }

        /* --- 2. UI 层 --- */
        .ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 20;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
        }
        .clickable { pointer-events: auto; }

        /* --- 3. 虚拟按键 (底部布局) --- */
        #controls {
            position: absolute; bottom: 20px; left: 0; width: 100%; height: 180px;
            pointer-events: none; z-index: 50;
            display: flex; justify-content: space-between;
            padding: 0 20px; box-sizing: border-box;
        }
        
        .btn-group {
            display: flex; gap: 15px; align-items: flex-end; pointer-events: auto;
        }

        .t-btn {
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            backdrop-filter: blur(5px);
            color: #fff;
            display: flex; justify-content: center; align-items: center;
            font-family: 'Orbitron'; font-weight: bold;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .t-btn:active, .t-btn.active {
            background: rgba(0, 210, 255, 0.4);
            transform: scale(0.9);
            border-color: #fff;
        }

        /* 方向键 */
        .btn-dir { width: 65px; height: 65px; font-size: 24px; }
        
        /* 功能键 */
        .btn-fly { width: 80px; height: 80px; border-color: #00d2ff; color: #00d2ff; font-size: 14px; }
        .btn-lens { 
            width: 60px; height: 60px; 
            border-color: #ff4d4d; color: #ff4d4d; font-size: 12px; 
            margin-bottom: 10px;
        }

        /* --- 4. HUD 信息 --- */
        #hud {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: none;
        }
        .hud-top {
            position: absolute; top: 15px; width: 100%;
            display: flex; justify-content: space-between; padding: 0 20px;
            box-sizing: border-box;
        }
        .fuel-box { width: 100px; }
        .fuel-track { height: 6px; background: #333; border: 1px solid #555; margin-top: 4px; transform: skewX(-15deg); }
        #fuel-bar { height: 100%; width: 100%; background: #00d2ff; transition: width 0.1s; }
        
        .star-box { 
            color: #ffd700; font-family: 'Orbitron'; font-size: 16px; 
            text-shadow: 0 0 5px #ffd700;
        }

        /* --- 5. 菜单样式 --- */
        .menu-screen {
            background: rgba(0, 0, 0, 0.92);
            backdrop-filter: blur(10px);
            transition: opacity 0.5s;
        }
        h1 {
            font-family: 'Orbitron'; font-size: 36px; margin: 0; text-align: center;
            background: linear-gradient(to bottom, #fff, #00d2ff);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .menu-btn {
            margin: 15px; padding: 15px 40px;
            border: 1px solid #00d2ff; color: #00d2ff;
            background: rgba(0, 210, 255, 0.1);
            font-family: 'Orbitron'; font-size: 18px;
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        .menu-btn.hard { border-color: #f00; color: #f00; background: rgba(255,0,0,0.1); }

        /* 隐藏关警告 */
        #warning-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: red; opacity: 0; pointer-events: none; z-index: 10;
            animation: none;
        }
        @keyframes flashAlarm {
            0%, 100% { opacity: 0; } 50% { opacity: 0.3; }
        }

    </style>
</head>
<body>

<div id="stars-bg"></div>

<div id="game-container">
    <canvas id="gameCanvas"></canvas>
    
    <!-- 红色警报闪烁层 -->
    <div id="warning-flash"></div>

    <!-- 顶部信息 -->
    <div id="hud">
        <div class="hud-top">
            <div class="fuel-box">
                <div style="font-size:10px; color:#aaa;">JETPACK</div>
                <div class="fuel-track"><div id="fuel-bar"></div></div>
            </div>
            <div class="star-box">
                DATA: <span id="cur-star">0</span>/<span id="max-star">3</span>
            </div>
        </div>
    </div>

    <!-- 底部虚拟按键 -->
    <div id="controls">
        <div class="btn-group">
            <div class="t-btn btn-dir" id="btn-left">←</div>
            <div class="t-btn btn-dir" id="btn-right">→</div>
        </div>
        <div class="btn-group">
            <div class="t-btn btn-lens" id="btn-lens">LENS</div>
            <div class="t-btn btn-fly" id="btn-fly">FLY</div>
        </div>
    </div>

    <!-- 开始菜单 -->
    <div id="start-screen" class="ui-layer menu-screen">
        <h1>MOON RUNNER</h1>
        <div style="color:#667; font-size:12px; margin-bottom:30px; letter-spacing:2px;">VERTICAL OPERATION</div>
        
        <button class="menu-btn clickable" onclick="initGame('NORMAL')">NORMAL</button>
        <button class="menu-btn hard clickable" onclick="initGame('HARD')">HARDCORE</button>
        
        <div style="margin-top:20px; font-size:11px; color:#555; text-align:center; line-height:1.5;">
            Collect ALL 3 STARS to enter<br>the Hidden Dimension.
        </div>
    </div>

    <!-- 胜利/结束菜单 -->
    <div id="end-screen" class="ui-layer menu-screen" style="opacity:0; pointer-events:none;">
        <h1 id="end-title">MISSION COMPLETE</h1>
        <div id="end-desc" style="color:#ccc; margin:20px; text-align:center;"></div>
        <button class="menu-btn clickable" onclick="location.reload()">RESTART</button>
    </div>
</div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// 竖屏逻辑分辨率
const W = 360;
const H = 640;
canvas.width = W;
canvas.height = H;

// --- 全局状态 ---
let SETTINGS = {};
const PRESETS = {
    NORMAL: { g: 0.25, acc: 0.5, fric: 0.8, maxV: 5.5, jet: 0.45, fuel: 100, regen: 1.5, canShoot: false },
    HARD: { g: 0.35, acc: 0.4, fric: 0.9, maxV: 6.5, jet: 0.6, fuel: 70, regen: 0.6, canShoot: true } // 困难模式敌人会射击
};

const KEYS = { Left:false, Right:false, Up:false, Lens:false };
const STATE = {
    mode: 'MENU', // MENU, PLAY, HIDDEN, END
    frame: 0, collected: 0, totalStars: 0,
    camY: 0, // 主要是垂直卷轴
    spawn: {x: 50, y: H - 100}
};

// 实体池
let platforms = [], stars = [], particles = [], enemies = [], bullets = [];
// 关键物体
let moonGate = {x: 0, y: 0, r: 40};
let trueCore = {x: 0, y: 0}; // 隐藏关终点

// --- 触摸控制系统 ---
function bindTouch(id, key) {
    const btn = document.getElementById(id);
    const start = (e) => { e.preventDefault(); KEYS[key] = true; btn.classList.add('active'); };
    const end = (e) => { e.preventDefault(); KEYS[key] = false; btn.classList.remove('active'); };
    btn.addEventListener('touchstart', start, {passive:false});
    btn.addEventListener('touchend', end, {passive:false});
    // PC调试兼容
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
}
bindTouch('btn-left', 'Left');
bindTouch('btn-right', 'Right');
bindTouch('btn-fly', 'Up');
bindTouch('btn-lens', 'Lens');

// 键盘兼容
window.addEventListener('keydown', e => {
    if(e.code==='ArrowLeft') KEYS.Left=true; if(e.code==='ArrowRight') KEYS.Right=true;
    if(e.code==='ArrowUp') KEYS.Up=true; if(e.code==='Space') KEYS.Lens=true;
});
window.addEventListener('keyup', e => {
    if(e.code==='ArrowLeft') KEYS.Left=false; if(e.code==='ArrowRight') KEYS.Right=false;
    if(e.code==='ArrowUp') KEYS.Up=false; if(e.code==='Space') KEYS.Lens=false;
});

// --- 实体类 ---

class Player {
    constructor() { this.w=16; this.h=24; this.reset(); }
    reset() {
        this.x = STATE.spawn.x; this.y = STATE.spawn.y;
        this.vx = 0; this.vy = 0; this.fuel = SETTINGS.fuel;
        this.grounded = false;
    }
    update() {
        // 水平移动
        if(KEYS.Left) this.vx -= SETTINGS.acc;
        if(KEYS.Right) this.vx += SETTINGS.acc;
        
        // 飞行
        if(KEYS.Up && this.fuel > 0) {
            if(this.vy > -SETTINGS.maxV) this.vy -= SETTINGS.jet;
            this.fuel -= 0.8; this.grounded = false;
            if(STATE.frame%3==0) spawnPart(this.x+8, this.y+24, 1, '#fa0');
        }

        // 物理
        this.vy += SETTINGS.g;
        this.vy *= 0.98; // 空气阻力
        this.vx *= this.grounded ? (this.ice ? 0.98 : SETTINGS.fric) : 0.95;
        
        // 燃料回复
        if(this.grounded && !KEYS.Up && this.fuel < SETTINGS.fuel) this.fuel += SETTINGS.regen;

        this.x += this.vx; this.y += this.vy;
        this.grounded = false; this.ice = false;

        // 边界限制 (左右)
        if(this.x < 0) this.x = 0;
        if(this.x > W - this.w) this.x = W - this.w;
        // 掉落死亡
        if(this.y > STATE.camY + H + 100) this.die();

        this.collide();
    }

    collide() {
        for(let p of platforms) {
            if(p.t === 1 && !KEYS.Lens) continue; // Phase block
            
            if(this.x < p.x+p.w && this.x+this.w > p.x && this.y+this.h > p.y && this.y < p.y+p.h) {
                if(p.t === 3) { this.die(); return; } // Spike
                
                // 落地检测
                if(this.vy >= 0 && (this.y+this.h - this.vy) <= p.y + 10) {
                    this.y = p.y - this.h; this.vy = 0; this.grounded = true;
                    if(p.t === 2) { this.ice = true; this.vx += p.s; } // Ice slide
                    if(p.t === 4 && !p.act) { // Checkpoint
                        p.act = true; STATE.spawn = {x:p.x, y:p.y-30};
                        spawnPart(p.x+p.w/2, p.y, 10, '#0f0');
                    }
                }
            }
        }
    }
    
    die() {
        spawnPart(this.x, this.y, 20, '#f00');
        this.reset();
        // 如果在隐藏关死亡，重新开始隐藏关
        if(STATE.mode === 'HIDDEN') {
            this.x = 50; this.y = -1000; // 隐藏关起点
        }
    }

    draw(ctx) {
        ctx.fillStyle = '#fff'; ctx.fillRect(this.x, this.y, this.w, this.h);
        // 背包
        ctx.fillStyle = this.fuel>10?'#0f0':'#f00'; ctx.fillRect(this.x-4, this.y+4, 4, 8);
        // 面罩
        ctx.fillStyle = '#00d2ff'; ctx.fillRect(this.x+4, this.y+4, 8, 6);
    }
}

class Enemy {
    constructor(x, y, range, type='WALKER') {
        this.x = x; this.y = y; this.sx = x; // spawn x
        this.range = range; this.type = type;
        this.w = 20; this.h = 20;
        this.dir = 1; this.speed = 1.5;
        this.lastShot = 0;
    }
    update() {
        // 巡逻逻辑
        this.x += this.speed * this.dir;
        if(Math.abs(this.x - this.sx) > this.range) this.dir *= -1;

        // 射击逻辑 (仅限困难模式 & 射手类型)
        if(SETTINGS.canShoot && this.type === 'SHOOTER') {
            if(STATE.frame - this.lastShot > 120) { // 2秒一发
                // 瞄准玩家
                let dx = (player.x+player.w/2) - (this.x+this.w/2);
                let dy = (player.y+player.h/2) - (this.y+this.h/2);
                let dist = Math.hypot(dx, dy);
                if(dist < 300) { // 射程内
                    bullets.push(new Bullet(this.x+10, this.y+10, dx/dist*3, dy/dist*3));
                    this.lastShot = STATE.frame;
                }
            }
        }

        // 碰撞玩家
        if(rectIntersect(this.x, this.y, this.w, this.h, player.x, player.y, player.w, player.h)) {
            player.die();
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#ff004d';
        // 简单的无人机形状
        ctx.beginPath(); 
        ctx.moveTo(this.x, this.y); ctx.lineTo(this.x+this.w, this.y); 
        ctx.lineTo(this.x+this.w/2, this.y+this.h); 
        ctx.fill();
        // 扫描眼
        ctx.fillStyle = '#fff';
        ctx.fillRect(this.x+this.w/2-2, this.y+5, 4, 4);
    }
}

class Bullet {
    constructor(x, y, vx, vy) {
        this.x = x; this.y = y; this.vx = vx; this.vy = vy;
        this.life = 100;
    }
    update() {
        this.x += this.vx; this.y += this.vy; this.life--;
        if(rectIntersect(this.x-3, this.y-3, 6, 6, player.x, player.y, player.w, player.h)) {
            player.die(); this.life = 0;
        }
    }
    draw(ctx) {
        ctx.fillStyle = '#ffeb3b';
        ctx.beginPath(); ctx.arc(this.x, this.y, 3, 0, Math.PI*2); ctx.fill();
    }
}

function rectIntersect(x1, y1, w1, h1, x2, y2, w2, h2) {
    return x2 < x1 + w1 && x2 + w2 > x1 && y2 < y1 + h1 && y2 + h2 > y1;
}

const player = new Player();

// --- 关卡系统 (垂直构建) ---

function initGame(mode) {
    SETTINGS = PRESETS[mode];
    document.getElementById('start-screen').style.opacity = 0;
    setTimeout(()=>document.getElementById('start-screen').style.display='none', 500);
    document.getElementById('hud').style.display = 'block';
    
    buildMainLevel();
    STATE.mode = 'PLAY'; STATE.collected = 0; STATE.frame = 0;
    player.reset();
    loop();
}

function buildMainLevel() {
    platforms = []; stars = []; enemies = []; bullets = [];
    STATE.camY = 0; STATE.spawn = {x: 100, y: 500};
    
    // 帮助函数
    const addP = (x,y,w,h,t,s=0) => platforms.push({x,y,w,h,t,s,act:false});
    const addStar = (x,y) => stars.push({x,y,c:false});

    // 1. 地面与基础
    addP(0, 550, 360, 50, 0);
    addP(50, 450, 80, 20, 0);
    addP(200, 350, 80, 20, 0); // Save 1
    addP(200, 350, 80, 20, 4); // Save Trigger

    // 2. 垂直上升 (知识锁)
    addP(50, 250, 60, 20, 1);
    addP(250, 150, 60, 20, 1);
    addStar(280, 120); // Star 1

    // 3. 冰面与尖刺 (向上)
    addP(100, 0, 160, 20, 2, 2); // 向右滑
    addP(280, 0, 80, 20, 0);
    addP(200, -100, 40, 20, 0);
    addP(50, -200, 100, 20, 0);
    addP(180, -200, 100, 20, 3); // Spike
    addStar(60, -230); // Star 2

    // 4. 最终塔楼
    addP(50, -350, 60, 20, 1);
    addP(250, -450, 60, 20, 1);
    addP(100, -550, 160, 20, 0); // Save 2
    addP(150, -550, 60, 20, 4);
    
    // 困难跳跃
    addP(300, -700, 60, 20, 2, -3);
    addStar(330, -730); // Star 3

    // 月球位置
    moonGate = {x: 180, y: -900, r: 50};
    addP(130, -820, 100, 20, 0);

    STATE.totalStars = stars.length;
    document.getElementById('max-star').innerText = STATE.totalStars;
}

function enterHiddenLevel() {
    // 切换状态
    STATE.mode = 'HIDDEN';
    STATE.spawn = {x: 50, y: -1000}; // 新起点
    player.reset();
    
    // 视觉特效
    document.getElementById('game-container').classList.add('dark-mode');
    document.getElementById('stars-bg').style.filter = 'hue-rotate(280deg) contrast(1.2)';
    document.getElementById('warning-flash').style.animation = 'flashAlarm 1s infinite';
    setTimeout(() => document.getElementById('warning-flash').style.animation = 'none', 3000);

    // 构建隐藏关地图 (位于主地图上方极远处)
    let baseY = -1000;
    
    // 起点
    platforms.push({x: 0, y: baseY + 50, w: 150, h: 20, t: 0});
    
    // 敌人长廊
    platforms.push({x: 150, y: baseY - 100, w: 200, h: 20, t: 0});
    enemies.push(new Enemy(200, baseY - 120, 80, 'WALKER')); // 巡逻兵
    
    // 垂直相位跳 + 射手
    platforms.push({x: 50, y: baseY - 250, w: 60, h: 20, t: 1});
    platforms.push({x: 250, y: baseY - 350, w: 60, h: 20, t: 1});
    // 浮空炮台
    platforms.push({x: 150, y: baseY - 450, w: 60, h: 20, t: 0});
    enemies.push(new Enemy(160, baseY - 470, 20, 'SHOOTER'));

    // 最终挑战
    platforms.push({x: 0, y: baseY - 600, w: 360, h: 20, t: 3}); // 全屏底刺
    platforms.push({x: 50, y: baseY - 650, w: 40, h: 10, t: 0});
    platforms.push({x: 270, y: baseY - 750, w: 40, h: 10, t: 0});
    platforms.push({x: 160, y: baseY - 850, w: 40, h: 10, t: 0});
    
    enemies.push(new Enemy(50, baseY - 900, 150, 'SHOOTER')); // 最终守卫

    // 核心
    trueCore = {x: 180, y: baseY - 950};
}

function gameLoop() {
    requestAnimationFrame(gameLoop);
    if(STATE.mode === 'MENU' || STATE.mode === 'END') return;
    STATE.frame++;

    player.update();

    // 相机垂直跟随 (缓动)
    let targetY = player.y - H * 0.6; // 玩家处于屏幕中下方
    STATE.camY += (targetY - STATE.camY) * 0.1;

    // 收集星星
    stars.forEach(s => {
        if(!s.c && Math.hypot(player.x-s.x, player.y-s.y) < 25) {
            s.c = true; STATE.collected++;
            document.getElementById('cur-star').innerText = STATE.collected;
            spawnPart(s.x, s.y, 15, '#ffd700');
        }
    });

    // 敌人逻辑 (仅在隐藏关或特定区域启用)
    enemies.forEach(e => e.update());
    for(let i=bullets.length-1; i>=0; i--) {
        bullets[i].update();
        if(bullets[i].life<=0) bullets.splice(i,1);
    }

    // 关卡出口逻辑
    if(STATE.mode === 'PLAY') {
        // 接触月球
        if(Math.hypot(player.x+8 - moonGate.x, player.y+12 - moonGate.y) < moonGate.r) {
            if(STATE.collected === STATE.totalStars) {
                enterHiddenLevel();
            } else {
                endGame(false, "Moon Reached... But data incomplete.");
            }
        }
    } else if (STATE.mode === 'HIDDEN') {
        // 接触真核心
        if(Math.hypot(player.x+8 - trueCore.x, player.y+12 - trueCore.y) < 30) {
            endGame(true, "HIDDEN DIMENSION CONQUERED!");
        }
    }

    draw();
}

function endGame(win, text) {
    STATE.mode = 'END';
    const screen = document.getElementById('end-screen');
    screen.style.opacity = 1; screen.style.pointerEvents = 'auto';
    document.getElementById('end-title').innerText = win ? "TRUE ENDING" : "MISSION END";
    document.getElementById('end-title').style.color = win ? "#00d2ff" : "#ccc";
    document.getElementById('end-desc').innerText = text;
}

function spawnPart(x, y, n, c) {
    for(let i=0; i<n; i++) particles.push({x, y, vx:(Math.random()-0.5)*5, vy:(Math.random()-0.5)*5, life:1, c});
}

function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.translate(0, -STATE.camY);

    // 1. 绘制物体
    // 月球 (仅在普通模式显示)
    if(STATE.mode === 'PLAY') {
        ctx.shadowBlur = 40; ctx.shadowColor = '#fff';
        ctx.fillStyle = '#eee'; ctx.beginPath(); ctx.arc(moonGate.x, moonGate.y, moonGate.r, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur = 0;
    } 
    // 真核心 (隐藏模式)
    else {
        ctx.shadowBlur = 40; ctx.shadowColor = '#f0f';
        ctx.fillStyle = '#fff'; 
        ctx.beginPath(); 
        let off = Math.sin(STATE.frame*0.1)*5;
        ctx.moveTo(trueCore.x, trueCore.y-20+off);
        ctx.lineTo(trueCore.x+20, trueCore.y+off);
        ctx.lineTo(trueCore.x, trueCore.y+20+off);
        ctx.lineTo(trueCore.x-20, trueCore.y+off);
        ctx.fill();
        ctx.shadowBlur = 0;
    }

    // 平台
    platforms.forEach(p => {
        if(p.t===0) { ctx.fillStyle='#345'; ctx.fillRect(p.x,p.y,p.w,p.h); ctx.fillStyle='#0df'; ctx.fillRect(p.x,p.y,p.w,2); }
        else if(p.t===1) { // Phase
            if(KEYS.Lens) { ctx.fillStyle='rgba(255,50,50,0.3)'; ctx.strokeStyle='#f55'; ctx.lineWidth=2; ctx.strokeRect(p.x,p.y,p.w,p.h); ctx.fillRect(p.x,p.y,p.w,p.h); }
            else { ctx.strokeStyle='rgba(255,50,50,0.2)'; ctx.setLineDash([4,4]); ctx.strokeRect(p.x,p.y,p.w,p.h); ctx.setLineDash([]); }
        }
        else if(p.t===2) { // Ice
            ctx.fillStyle='rgba(150,220,255,0.5)'; ctx.fillRect(p.x,p.y,p.w,p.h);
            let off = (p.s>0 ? STATE.frame : -STATE.frame)%20;
            ctx.fillStyle='#fff'; for(let i=0; i<p.w; i+=20) if(p.x+i+off<p.x+p.w) ctx.fillRect(p.x+i+off, p.y+5, 2, 2);
        }
        else if(p.t===3) { // Spike
            ctx.fillStyle='#f00'; ctx.beginPath();
            for(let i=0; i<p.w; i+=10) { ctx.moveTo(p.x+i, p.y+p.h); ctx.lineTo(p.x+i+5, p.y); ctx.lineTo(p.x+i+10, p.y+p.h); }
            ctx.fill();
        }
        else if(p.t===4) { // Save
            ctx.fillStyle = p.act ? '#2f5' : '#567'; ctx.fillRect(p.x, p.y, p.w, p.h);
            if(p.act) { ctx.fillStyle='rgba(50,255,100,0.2)'; ctx.fillRect(p.x, p.y-100, p.w, 100); }
        }
    });

    // 星星
    stars.forEach(s => {
        if(!s.c) {
            ctx.fillStyle='#ffd700'; ctx.shadowBlur=10; ctx.shadowColor='#ffd700';
            ctx.save(); ctx.translate(s.x, s.y+Math.sin(STATE.frame*0.1)*5); ctx.rotate(STATE.frame*0.05);
            ctx.fillRect(-6,-6,12,12); ctx.restore(); ctx.shadowBlur=0;
        }
    });

    // 敌人与子弹
    enemies.forEach(e => e.draw(ctx));
    bullets.forEach(b => b.draw(ctx));

    player.draw(ctx);

    // 粒子
    for(let i=particles.length-1; i>=0; i--) {
        let p=particles[i]; p.x+=p.vx; p.y+=p.vy; p.life-=0.05;
        ctx.globalAlpha=p.life; ctx.fillStyle=p.c; ctx.fillRect(p.x,p.y,3,3);
        if(p.life<=0) particles.splice(i,1);
    }
    ctx.globalAlpha=1;

    ctx.restore();

    // UI特效：透镜红框
    if(KEYS.Lens) {
        ctx.strokeStyle = 'rgba(255,0,0,0.3)'; ctx.lineWidth=4; ctx.strokeRect(0,0,W,H);
    }
    // UI 更新
    document.getElementById('fuel-bar').style.width = player.fuel + "%";
}
</script>
</body>
</html>
